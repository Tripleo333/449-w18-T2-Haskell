deleteList :: [[Int]] -> [[Int]] -> [Int] -> [[Int]]
deleteList x, (y:ys), z
    |   y == z = x ++ z
    |   otherwise = deleteList (x ++ y), ys, z

constraints = {}

-- State -> Next Empty Index -> Current Minimum -> current penalty -> Constraints -> (Final State, Penalty)
branch :: [Char] -> Int -> Int -> Int -> Constraints -> ([Char], Int)
-- Check constraints pattern matching, x y z is last resort after it passes all constraints
branch x 8 z
    |
branch x y z
    |
    |   not ('A' `elem` x) = branch (x ++ 'A') (y + 1) z
-- .. do rest
